Перед выполнением заданий важно самостоятельно повторить шаги, выполняемые на уроке.

1) Подключить пустой диск и создать на нем два основных и два логических раздела.
2) Смонтировать в них несколько пустоых корневых каталогов.
3) Перенести каталог /home на отдельный раздел.
4) Создать еще один раздел подкачки.
5) Добавить еще два диска и создать на нем несколько логических томов (LVM).
6) Попробовать переносить тома с одного жесткого диска на другой без остановки ОС.
7) Определить точную версию ядра ОС.

ПРОВЕРКА ОТ ГПТ

---

**1) Подключить пустой диск и создать на нем два основных и два логических раздела.**

*   **Ваше решение:** `fdisk /dev/sdX -> n -> 2 primary, 1 extended, внутри extended 2 logical -> получаем разделы sdXY, где Y - номер раздела`
*   **Проверка:** **Верно.**
    *   Используется `fdisk` для диска `/dev/sdX`.
    *   `n` - создать новый раздел.
    *   Процедура:
        1.  `n` -> `p` (primary) -> `1` -> размеры -> `w` (записать и выйти, если это все) ИЛИ продолжить.
        2.  `n` -> `p` (primary) -> `2` -> размеры.
        3.  `n` -> `e` (extended) -> `3` -> размеры (обычно до конца диска).
        4.  `n` -> `l` (logical) -> размеры (это будет `/dev/sdX5`).
        5.  `n` -> `l` (logical) -> размеры (это будет `/dev/sdX6`).
        6.  `w` (записать изменения и выйти).
    *   **Важно:** После изменения таблицы разделов ядро может не сразу увидеть новые разделы. Используйте команды `partprobe /dev/sdX` или `kpartx -a /dev/sdX` (если установлен) или перезагрузитесь (менее предпочтительно), чтобы ядро перечитало таблицу.
*   **Вердикт:** Процесс описан правильно. Не забудьте про `partprobe`.

---

**2) Смонтировать в них несколько пустых корневых каталогов.**

*   **Ваше решение:** `mount /dev/sdXY /`
*   **Проверка:** **Неверно и опасно!**
    *   Команда `mount /dev/sdXY /` попытается смонтировать ваш новый раздел в **корневой каталог (`/`)** существующей системы. Это **перекроет** доступ ко всем файлам и каталогам вашей работающей ОС в корне, и система, скорее всего, перестанет функционировать!
    *   **Правильный подход:**
        1.  **Создать точки монтирования:** Нужно создать пустые каталоги, куда будут монтироваться разделы. Например:
            ```bash
            sudo mkdir /mnt/part1
            sudo mkdir /mnt/part2
            sudo mkdir /mnt/part5
            sudo mkdir /mnt/part6
            ```
        2.  **(Опционально, но рекомендуется) Отформатировать разделы:** Перед монтированием разделы нужно отформатировать в какую-либо файловую систему (если они еще не отформатированы).
            ```bash
            sudo mkfs.ext4 /dev/sdX1
            sudo mkfs.ext4 /dev/sdX2
            sudo mkfs.ext4 /dev/sdX5
            sudo mkfs.ext4 /dev/sdX6
            ```
        3.  **Смонтировать в созданные каталоги:**
            ```bash
            sudo mount /dev/sdX1 /mnt/part1
            sudo mount /dev/sdX2 /mnt/part2
            sudo mount /dev/sdX5 /mnt/part5
            sudo mount /dev/sdX6 /mnt/part6
            ```
*   **Вердикт:** Ваша команда монтирования некорректна и опасна. Нужно создавать отдельные точки монтирования и монтировать разделы в них.

---

**3) Перенести каталог /home на отдельный раздел.**

*   **Ваше решение:** `fdisk /dev/sdX -> новый раздел Y -> mv /home /dev/sdXY (перенос существующих файлов) -> mount /dev/sdXY /home`
*   **Проверка:** **Концептуально верно, но команды некорректны.** Перенос `/home` — стандартная, но ответственная процедура.
    *   `fdisk /dev/sdX -> новый раздел Y`: **Верно.** Нужно создать раздел для `/home` (например, `/dev/sdX7`). Не забудьте `partprobe`.
    *   **(Пропущено) Форматирование:** Новый раздел нужно отформатировать: `sudo mkfs.ext4 /dev/sdX7` (или другая ФС).
    *   `mv /home /dev/sdXY`: **Абсолютно неверно!** Нельзя переместить каталог `/home` напрямую на блочное устройство `/dev/sdX7`. Нужно скопировать содержимое `/home` в *смонтированный* новый раздел.
    *   `mount /dev/sdXY /home`: **Почти верно, но не в тот момент.**
    *   **Правильная последовательность (примерная):**
        1.  Создать раздел `/dev/sdX7`, отформатировать его (`mkfs.ext4 /dev/sdX7`).
        2.  **Переключиться в однопользовательский режим или загрузиться с LiveCD/USB:** Это важно, чтобы никто не писал в `/home` во время переноса.
            ```bash
            sudo systemctl isolate rescue.target # Или telinit 1 для SysVinit
            ```
        3.  **Смонтировать новый раздел во временную точку:**
            ```bash
            sudo mkdir /mnt/newhome
            sudo mount /dev/sdX7 /mnt/newhome
            ```
        4.  **Скопировать данные из старого `/home` в новый:** Использовать `rsync` или `cp -a` для сохранения прав и атрибутов.
            ```bash
            sudo rsync -avh /home/ /mnt/newhome/
            # ИЛИ
            # sudo cp -a /home/* /mnt/newhome/
            ```
        5.  **Сравнить содержимое (опционально, но рекомендуется):** Убедиться, что все скопировалось.
        6.  **Переименовать старый каталог `/home` (для бэкапа):**
            ```bash
            sudo mv /home /home_old
            ```
        7.  **Создать новую пустую точку монтирования `/home`:**
            ```bash
            sudo mkdir /home
            ```
        8.  **Размонтировать временную точку:**
            ```bash
            sudo umount /mnt/newhome
            ```
        9.  **Смонтировать новый раздел в `/home`:**
            ```bash
            sudo mount /dev/sdX7 /home
            ```
        10. **Проверить, что все работает:** `ls /home`, попробовать войти под пользователем (после возврата в обычный режим).
        11. **Добавить запись в `/etc/fstab`:** Чтобы новый `/home` монтировался автоматически при загрузке. Найдите UUID раздела (`sudo blkid /dev/sdX7`) и добавьте строку вроде:
            ```
            UUID=<UUID_раздела_sdX7> /home ext4 defaults 0 2
            ```
        12. **Вернуться в обычный режим:**
            ```bash
            sudo systemctl isolate default.target # Или telinit 5/3 для SysVinit
            # или просто reboot
            ```
        13. **Удалить `/home_old`:** После полной уверенности, что все работает.
            ```bash
            sudo rm -rf /home_old
            ```
*   **Вердикт:** Концепция верна, но реализация требует более сложной и аккуратной последовательности действий, включая копирование данных и редактирование `/etc/fstab`. `mv` на блочное устройство не сработает.

---

**4) Создать еще один раздел подкачки.**

*   **Ваше решение:** `не знаю`
*   **Решение:**
    1.  **Создать раздел:** С помощью `fdisk` или `gdisk` создать новый раздел (например, `/dev/sdX8`).
    2.  **Установить тип раздела:** В `fdisk`/`gdisk` установить тип раздела "Linux swap" (код `82` для MBR/GPT, GUID `0657FD6D-A4AB-43C4-84E5-0933C84B4F4F` для GPT). Не забудьте `partprobe`.
    3.  **Отформатировать раздел как swap:**
        ```bash
        sudo mkswap /dev/sdX8
        ```
    4.  **Активировать swap-раздел:**
        ```bash
        sudo swapon /dev/sdX8
        ```
    5.  **Проверить:** Убедиться, что новый swap активен.
        ```bash
        swapon -s
        # или
        free -h
        ```
    6.  **(Опционально) Добавить в `/etc/fstab` для автоактивации:** Найти UUID (`sudo blkid /dev/sdX8`) и добавить строку:
        ```
        UUID=<UUID_раздела_sdX8> none swap sw 0 0
        ```
*   **Вердикт:** Процесс включает создание раздела правильного типа, форматирование с `mkswap` и активацию с `swapon`.

---

**5) Добавить еще два диска и создать на них несколько логических томов (LVM).**

*   **Ваше решение:** `пусть sdb и sdc - новые диски -> создаем по 1 разделу на каждом через fdisk с кодом 8e-> pvcreate /dev/sdb1 /dev/sdc1 -> sudo vgcreate storage_vg /dev/sdb1 /dev/sdc1 -> lvcreate -n lv1 -L 15G storage_vg -> lvcreate -n lv2 -L 15G storage_vg`
*   **Проверка:** **Отлично!** Весь процесс описан абсолютно правильно:
    1.  Подготовка дисков (`sdb`, `sdc`).
    2.  Создание разделов (`sdb1`, `sdc1`) с типом `8e` (Linux LVM).
    3.  Инициализация разделов как Физических Томов (`pvcreate`).
    4.  Создание Группы Томов (`vgcreate`) из этих PV.
    5.  Создание Логических Томов (`lvcreate`) нужного размера из VG.
*   **Вердикт:** Идеально.

---

**6) Попробовать переносить тома с одного жесткого диска на другой без остановки ОС.**

*   **Ваше решение:** `не знаю`
*   **Решение:** Это одна из ключевых возможностей LVM, реализуется командой `pvmove`. Предположим, у вас есть VG `storage_vg`, включающая PV `/dev/sdb1` и `/dev/sdc1`, и вы хотите переместить все данные с `/dev/sdb1` на `/dev/sdc1` (при условии, что на `/dev/sdc1` достаточно свободного места для всех экстентов с `/dev/sdb1`).
    ```bash
    # Посмотреть распределение LV по PV (опционально)
    sudo lvdisplay -m

    # Запустить перемещение ВСЕХ экстентов с /dev/sdb1 на другие PV в той же VG
    # LVM сам найдет, куда перемещать (в данном случае, на /dev/sdc1)
    sudo pvmove /dev/sdb1

    # Можно указать и целевой PV, если их несколько:
    # sudo pvmove /dev/sdb1 /dev/sdc1

    # Процесс может занять время, можно следить за прогрессом в другом терминале
    # через pvdisplay, lvdisplay, или запустить pvmove в фоне (опция -b)
    # и следить через 'ps aux | grep pvmove' или логи.

    # После завершения pvmove, можно удалить /dev/sdb1 из VG, если он пуст
    # Проверить, что на /dev/sdb1 не осталось используемых PE: sudo pvdisplay /dev/sdb1
    sudo vgreduce storage_vg /dev/sdb1
    sudo pvremove /dev/sdb1
    ```
    Эта операция выполняется **"на лету" (онлайн)**, приложения, использующие файловые системы на LV, которые перемещаются, продолжат работать (хотя может наблюдаться некоторое снижение производительности во время `pvmove`).
*   **Вердикт:** Команда `pvmove` — это то, что нужно.

---

**7) Определить точную версию ядра ОС.**

*   **Ваше решение:** `ls -al /boot -> символическая ссылка vmlinuz -> vmlinuz-6.8.0-58-generic -> версия: 6.8.0-58`
*   **Проверка:** **Не совсем точно и не самый лучший способ.**
    *   Символическая ссылка `vmlinuz` в `/boot` обычно указывает на ядро, которое было **загружено последним по умолчанию**, но не обязательно то, которое **загружено сейчас**. Вы могли выбрать другое ядро в меню GRUB.
    *   Имя файла (`vmlinuz-6.8.0-58-generic`) действительно содержит версию, но парсить его вручную ненадежно.
    *   **Правильный и надежный способ:** Использовать команду `uname`.
        ```bash
        uname -r
        # Вывод: 6.8.0-58-generic
        # или
        uname -a
        # Вывод: Linux hostname 6.8.0-58-generic #1 SMP PREEMPT_DYNAMIC x86_64 x86_64 x86_64 GNU/Linux
        ```
        Команда `uname -r` (kernel release) специально предназначена для вывода версии **текущего загруженного** ядра.
*   **Вердикт:** Ваш метод может сработать, но не гарантирует точности. `uname -r` — стандартный и правильный способ.

---

**Общий Итог:** Вы демонстрируете хорошее понимание `fdisk` и основ LVM. Основные ошибки касались монтирования (не монтировать в `/`) и перемещения каталога `/home` (нужно копировать данные, а не `mv` на устройство). Команды для swap и `pvmove` были вам неизвестны, а определение версии ядра лучше делать через `uname`. Отличная работа над сложными задачами!
